[(Back to DB)](../README.md)

## Database guidelines (Postgres)

### In this page
- [Quick checklist](#quick-checklist)
- [Naming](#naming)
- [Primary keys](#primary-keys)
- [Foreign keys and actions](#foreign-keys-and-actions)
- [Timestamps](#timestamps)
- [RLS (Row Level Security)](#rls-row-level-security)
- [Views](#views)
- [Indexes](#indexes)
- [Data types](#data-types)
- [RPCs / Functions](#rpcs--functions)
- [Migrations](#migrations)
- [Mapping tables and relationships](#mapping-tables-and-relationships)
- [Constants and enums](#constants-and-enums)
- [Auditing (pgAudit)](#auditing-pgaudit)

This file documents conventions and rules for a Postgres-backed relational schema.

### Quick checklist
- [ ] Table name is singular (e.g., `tenant`, `profile`, `call`).
- [ ] Column names avoid plurals; use descriptive postfixes for collections (e.g., `email_list`, `permission_map`).
- [ ] Primary key is `<table>_id bigint generated by default as identity`.
- [ ] All foreign keys named after referenced PKs (e.g., `tenant_id`) with correct delete action:
  - [ ] `on delete cascade` for owned children
  - [ ] `on delete set null` for optional relations
- [ ] `created_at timestamptz default now()` and `updated_at timestamptz default now()` exist.
- [ ] `trigger_set_updated_at()` attached to the table.
- [ ] RLS enabled on the table and policies defined:
  - [ ] `<table>_select` scoped by `tenant_id` via `is_member_of`
  - [ ] `<table>_admin_all` allows platform admins
- [ ] Indexes follow `idx_<table>_<column_or_purpose>` and exist for:
  - [ ] Foreign keys
  - [ ] Common filters/sorts (e.g., `(tenant_id, created_at desc)`)
- [ ] No views introduced; computed needs handled in app or materialized tables if required.
- [ ] Data types:
  - [ ] Use `timestamptz` for timestamps
  - [ ] Use `citext` where case-insensitive text is needed
- [ ] Enums vs lookups decided appropriately:
  - [ ] Enum only for tiny, stable sets
  - [ ] Lookup table for mutable domain values
- [ ] Mapping relationships:
  - [ ] 1:n puts FK on child with correct cascade/null semantics
  - [ ] n:n uses mapping table `<left>_<right>` with identity PK, unique pair, FK indexes
- [ ] RPCs / functions:
  - [ ] Use typed IDs (e.g., `bigint tenant_id`)
  - [ ] Use `security definer` sparingly; validate inputs
- [ ] Auditing:
  - [ ] pgAudit configured (preferred) or app-level audit triggers present where needed
- [ ] Migrations are idempotent and include backfill plan for identity PKs.

### Naming
- **Singular table names**: `tenant`, `profile`, `tenant_user`, `phone_number`, `call`, `credit_transaction`.
  - Rationale: reads like an entity, avoids pluralization edge cases, and composes better with PK/FK names.
  - Risks: diverges from some ORMs' defaults; requires discipline during migrations/renames.
  - Exceptions: third‑party schemas you don't control; keep as‑is and isolate behind views in the app layer.
- **Column naming**: avoid plurals; use descriptive postfixes for collections.
  - Examples: `employer_email_list` instead of `employer_emails`, `user_permission_map` instead of `user_permissions`.
  - Rationale: makes data structure types immediately clear and avoids pluralization edge cases.
  - Risks: requires discipline in schema design and migrations.
  - Exceptions: third-party integrations that require specific column names.
- **Primary key**: each table has a single identity column named `<table>_id`, e.g. `tenant_id`, `call_id`.
  - Rationale: predictable joins and fewer "what does id refer to?" ambiguities across tables.
  - Risks: switching from UUIDs/natural keys requires backfill and cutover planning.
  - Exceptions: when keys must be globally unique and client‑generated (offline ops, replication), use UUID v7.
- **Foreign keys**: columns are named after the referenced table's pk, e.g. `tenant_id`, `phone_number_id`, `call_id`.
  - Rationale: self-documenting relationships and consistent query ergonomics.
  - Risks: inconsistent naming increases onboarding time and query errors.
  - Exceptions: polymorphic relationships; prefer explicit join tables instead.
- **Snake case**: use lower_snake_case for all identifiers.
  - Rationale: maximizes portability and readability across tools and languages.
  - Risks: none significant; minor friction with camelCase code styles (solve via mappers/aliases).

### Primary keys
- Use `bigint generated by default as identity` for `<table>_id`.
  - Rationale: native, fast, monotonically increasing keys that are easy to reason about.
  - Risks: predictable sequences can leak approximate record counts; consider gap‑filling sequences only if needed.
  - Exceptions: sharded/multi‑region setups where snowflake/UUID keys are operationally simpler.
- Do not use a generic `id` column and avoid UUIDs unless required for external systems.
  - Rationale: `id` is ambiguous in joins; UUIDs bloat indexes and are slower to scan without strong justification.
  - Risks: UUID avoidance can be problematic for cross‑system de‑duplication.
  - Exceptions: public identifiers, sync tokens, or when exposure of sequential IDs is a concern.

### Foreign keys and actions
- Prefer `on delete cascade` for ownership relations (e.g., `tenant` → child rows).
  - Rationale: prevents orphan rows and simplifies cleanup when a parent is removed.
  - Risks: misapplied cascades can delete large swaths of data; require constraints review.
  - Exceptions: legal/audit records that must persist; use `restrict` and archive instead.
- Prefer `on delete set null` for optional relationships (e.g., `call.phone_number_id`, `credit_transaction.call_id`).
  - Rationale: preserves dependent data while acknowledging optionality.
  - Risks: nulls can complicate queries; ensure NOT NULL where truly required.
  - Exceptions: if business rules require reassignment instead, handle in application logic.
- Index foreign keys if they're used in filters or joins.
  - Rationale: avoids table scans on common access paths and keeps FK checks efficient.
  - Risks: over‑indexing hurts write performance and storage; audit with `pg_stat_user_indexes`.

### Timestamps
- Every table includes `created_at timestamptz not null default now()` and `updated_at timestamptz not null default now()`.
  - Rationale: universal audit fields simplify debugging and analytics.
  - Risks: clock skew in distributed systems; prefer DB server time and avoid client‑provided timestamps.
  - Exceptions: immutable audit/archive tables may omit `updated_at`.
- Maintain `updated_at` via a common trigger `trigger_set_updated_at()` applied to each table.
  - Rationale: removes application boilerplate and guarantees correctness.
  - Risks: hidden writes from triggers can surprise apps relying on row hashes; document behavior.
  - Exceptions: high‑volume append‑only tables; skip `updated_at` for write throughput.

### RLS (Row Level Security)
- Enable RLS on all domain tables.
  - Rationale: default-deny posture; data access is explicit via policies.
  - Risks: misconfigured policies can leak or block data; always test with `ALTER ROLE SET role` in CI.
  - Exceptions: purely internal/system tables without tenant/user data.
- Helper functions: `is_platform_admin()` and `is_member_of(tenant_id bigint)`.
  - Rationale: centralizes common checks, keeping policies concise and reusable.
  - Risks: function bugs affect all tables; keep them simple and stable.
- Policy naming: `<table>_select`, `<table>_admin_all` (or more granular as needed).
  - Rationale: predictable naming helps locate and audit access rules quickly.
- Typical rules:
  - Members can `select` rows scoped by `tenant_id` using `is_member_of`.
  - Platform admins can `select` and `manage` all.
  - Rationale: least-privilege by default with an explicit escape hatch for operators.
  - Risks: performance overhead in complex predicates; index by `tenant_id` consistently.
  - Exceptions: service-role operations bypass RLS by design; restrict credentials tightly.

### Views
- Avoid database views in favor of application-layer queries or materialized tables when needed.
  - Rationale: views complicate RLS and migrations; app-layer logic is easier to evolve and test. Use materialized tables when precomputation is necessary.
  - Risks: moving logic to app can duplicate queries; mitigate with shared query builders.
  - Exceptions: stable read-only reporting where views add clarity and do not intersect with RLS.

### Indexes
- Name as `idx_<table>_<column_or_purpose>`, e.g. `idx_call_tenant_started_at`, `idx_credit_transaction_kind`.
  - Rationale: makes EXPLAIN outputs understandable and maintenance straightforward.
- Create multi-column indexes for common query patterns (e.g., `(tenant_id, created_at desc)`).
  - Rationale: match actual filters/sorts to avoid redundant indexes; review via `pg_stat_statements`.
  - Risks: wrong column order defeats planner use; validate with `EXPLAIN ANALYZE`.
  - Exceptions: tiny tables where seq scans are cheaper.

### Data types
- Use `citext` when case-insensitive text comparisons are needed.
  - Rationale: correctness with simpler queries (`=` works without manual LOWER()).
  - Risks: collation nuances; test sorting behavior across locales.
  - Exceptions: performance‑critical paths; consider functional indexes on `lower(column)` instead.
- Prefer `timestamptz` for all timestamps.
  - Rationale: stores absolute time and avoids timezone bugs.
  - Risks: display formatting complexity moves to the app (expected).
  - Exceptions: use `date` for all‑day values without time or timezone.
- **JSON columns**: use descriptive names that indicate structure type.
  - Examples: `email_list` (JSON array), `permission_map` (JSON object), `configuration_array` (JSON array).
  - Rationale: makes it clear what data structure is stored and how to query it.
  - Risks: requires discipline in naming; inconsistent naming makes queries harder to understand.
  - Exceptions: when storing polymorphic data where structure varies significantly.

### RPCs / Functions
- Functions should operate with typed IDs matching the schema (e.g., `bigint tenant_id`).
  - Rationale: prevents implicit casts and hard-to-debug mismatches.
- `security definer` sparingly; validate inputs and enforce RLS logic or admin checks.
  - Rationale: reduces privilege escalation risk; keep definer functions narrowly scoped.
  - Risks: definer functions run with elevated privileges; never concatenate SQL (use parameters).
  - Exceptions: maintenance/admin routines guarded by role checks and limited to operators.

### Migrations
- Backfill existing data to new identity PKs before switching consumers.
  - Rationale: ensures continuity for references and prevents downtime.
  - Risks: long‑running backfills on large tables; use batched migrations and cutover toggles.
- Apply `create table if not exists` and `alter table if exists add column if not exists` for idempotency where practical.
  - Rationale: smooth local/dev/bootstrap flows and safer re-runs during CI.
  - Risks: idempotency can hide partial failures; add verification queries post‑migration.

### Mapping tables and relationships
- 1:n (one-to-many): put the FK on the "many" side.
  - Pattern: child table has `<parent>_id bigint not null references <parent>(<parent>_id)`.
  - Delete behavior: `on delete cascade` if the child is owned by the parent; `on delete set null` if the relationship is optional and the child can live on.
  - Indexing: create an index on the FK to support joins and filters (`idx_<child>_<parent>_id`).
  - Rationale: the simplest, most performant model for hierarchical ownership.
  - Risks: changing ownership tree can require expensive data moves.
  - Exceptions: when children must outlive parents for compliance, replace cascade with restrict + archival.

- n:n (many-to-many): use a dedicated mapping table.
  - Naming: `<left>_<right>` (both singular), e.g. `tenant_user`.
    - Do not add a `_map` suffix; it's redundant and lengthens identifiers.
    - Exception: if `<left>_<right>` collides with an existing domain table name, consider `_link` as a suffix.
  - Columns:
    - Identity PK: `<left>_<right>_id bigint generated by default as identity primary key`.
    - FKs: `<left>_id` references `<left>(<left>_id)`, `<right>_id` references `<right>(<right>_id)`.
    - Timestamps: `created_at`, `updated_at` with the shared trigger.
  - Constraints:
    - `unique (<left>_id, <right>_id)` to prevent duplicates.
  - Delete behavior:
    - `on delete cascade` on both FKs so mappings are removed when either side is deleted.
  - Indexing:
    - Add indexes on both FKs for directional lookups: `idx_<map>_<left>_id`, `idx_<map>_<right>_id`.
  - Rationale: keeps the join table independent yet performant and deduplicated.
  - Risks: identity PK can mask duplicate pair insertion bugs if unique constraint is missing.
  - Exceptions: temporal n:n relationships (history); add validity windows (`valid_from`, `valid_to`) and allow overlapping only by rule.

- When to split n:n into two 1:n with a first-class association entity:
  - If the relationship itself has attributes (e.g., role, status, metadata) or lifecycle (effective dates), model the association as its own noun (e.g., `membership`) rather than a generic join.
  - Rationale: better domain clarity and allows constraints/indexes on relationship attributes.
  - Risks: additional table and code paths; justified when behavior/attributes exist on the link.

### Constants and enums
- Postgres enums: use for small, stable sets that change very rarely (e.g., `transaction_type`).
  - Naming: lowercase, snake_case type names like `transaction_type`, `membership_role`.
  - Rationale: tight validation and compact storage; but migrations require ALTER TYPE to add values.
  - Risks: adding/removing enum values is operationally heavier; avoid frequent changes.
  - Exceptions: when values evolve often, prefer lookup tables.

- Lookup tables (preferred for mutable/domain-managed lists):
  - Pattern: table with `<lookup>_id identity` + `name` + `status` (or attributes) and optional `tenant_id` if tenant-scoped.
  - Reference via FK from domain tables; add `on delete restrict` (or `set null` if optional).
  - Rationale: easier to add/soft-delete values, attach metadata, and audit changes.
  - Risks: data drift if lookups are tenant-scoped; add unique constraints per tenant.
  - Exceptions: truly global constants; keep tenant_id null and enforce uniqueness globally.

- Configuration constants:
  - Use a `system_config` (or scoped `tenant_config`) table for key/value JSON if values are not relational.
  - Keep keys namespaced and validated at the application layer.
  - Rationale: flexible, avoids schema churn for infrequently changing flags.
  - Risks: JSON keys become opaque; enforce validation in app and add partial indexes when filtering.
  - Exceptions: relational configs; model as typed columns in a proper table.

### Auditing (pgAudit)
- Enable pgAudit to capture DDL/DML activity at the server level.
  - Extension: `create extension if not exists pgaudit;` (if supported by your Postgres hosting).
  - Recommended settings (set via DB parameters):
    - `pgaudit.log = 'write, ddl, function'` (include inserts/updates/deletes, DDL, and function calls)
    - `pgaudit.log_parameter = on` (log function parameters; ensure no sensitive secrets in plain text)
  - Rationale: centralized, tamper-evident auditing without per-table triggers.
  - Risks: high log volume and potential sensitive data exposure; redact or avoid logging secrets.
  - Exceptions: managed Postgres without pgAudit; fall back to app-level auditing.

- Capturing user and IP in logs:
  - Postgres logging: set `log_line_prefix` to include user, DB, remote addr, and application name, e.g.
    - `log_line_prefix = '%m [%p] user=%u db=%d remote=%r app=%a '`
  - App session propagation: set these per-connection (immediately after connect):
    - `SET application_name = 'api user=<app_user_id>';`
    - Optionally set custom GUCs for use in triggers: `SET app.user_id = '<uuid>'; SET app.ip = '<client_ip>';`
  - In SQL (for trigger-based audit tables), you can read:
    - `current_setting('app.user_id', true)` (may be null)
    - `current_setting('app.ip', true)` (may be null)
    - `inet_client_addr()` / `inet_client_port()` for server-seen client address/port
  - Rationale: `%r` gives the DB-visible source (often the app server). Propagating app user/IP via `application_name` or custom GUCs makes logs correlate to real actors.
  - Risks: behind proxies you won't see end-user IP at the DB; ensure the app forwards it via GUC or `application_name`.
  - Exceptions: where PII policy forbids IP logging; store hashed or truncated values.

- Application-level audit (when pgAudit isn't available or for fine-grained trails):
  - Use per-table `AFTER INSERT/UPDATE/DELETE` triggers to write to an `audit_log` table with: table name, pk, user_id, action, changed columns, old/new values snapshot (JSON), timestamps.
  - Scope with RLS-aware user identity (`auth.uid()` where available) and avoid storing sensitive secrets.
  - Rationale: portable and queryable in-app history with precise context.
  - Risks: write amplification and storage growth; prune and archive periodically.
  - Exceptions: high-throughput hot tables; sample or aggregate events instead of row-level auditing.

---

_Last updated: 2025-09-17_

 
